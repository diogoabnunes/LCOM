#include "video.h"

static void *video_mem;		/* Process (virtual) address to which VRAM is mapped */

static unsigned h_res;	        /* Horizontal resolution in pixels */
static unsigned v_res;	        /* Vertical resolution in pixels */
static unsigned bits_per_pixel; /* Number of VRAM bits per pixel */
static unsigned color_mode;     /* Value of the color mode */
static unsigned bytes_per_pixel; /* Number of bytes a pixel ocuppies, in a certain video mode */

int r;
struct minix_mem_range mr;
static unsigned int vram_base;  /* VRAM's physical addresss */
static unsigned int vram_size;  /* VRAM's size, but you can use the frame-buffer size, instead */

static unsigned RedMaskSize;
static unsigned RedFieldPosition;
static unsigned GreenMaskSize;
static unsigned GreenFieldPosition;
static unsigned BlueMaskSize;
static unsigned BlueFieldPosition;

uint32_t get_lsb(uint32_t value, uint32_t num_bits)
{

  value <<= (32 - num_bits);
  value >>= (32 - num_bits);

  return value;
}

int set_graphics_mode(uint16_t mode)
{
	reg86_t reg86;

	memset(&reg86, 0, sizeof(reg86));

	reg86.intno = VIDEOCARD_SERVICE;
	reg86.ax = SET_VBE_MODE;
	reg86.bx = SET_LINEAR_MODE | mode;

	if(sys_int86(&reg86) != OK) {
		printf("vg_exit(): sys_int86() failed \n");
		return 1;
	}

	if(reg86.ah != 0)
		return 1;

	return 0;
}

int get_vram_info(uint16_t mode)
{
	vbe_mode_info_t vmi_p;

	if(vbe_get_mode_info(mode, &vmi_p) != 0)
    	return 1;

  	h_res = vmi_p.XResolution; //updates hor resolution
  	v_res = vmi_p.YResolution;  //updates vert resolution
  	bits_per_pixel = vmi_p.BitsPerPixel; //updates the bits per pixel
  	vram_base = vmi_p.PhysBasePtr;  //updates the vram physical address
  	color_mode = vmi_p.MemoryModel; //updates the color mode
  
  	RedMaskSize = vmi_p.RedMaskSize;
  	RedFieldPosition = vmi_p.RedFieldPosition;
  	GreenMaskSize = vmi_p.GreenMaskSize;
  	GreenFieldPosition = vmi_p.GreenFieldPosition;
  	BlueMaskSize = vmi_p.BlueMaskSize;
  	BlueFieldPosition = vmi_p.BlueFieldPosition;

  	bytes_per_pixel = bits_per_pixel;

  	//number is not even
  	if((bytes_per_pixel % 2) != 0)
    	bytes_per_pixel++;

  	bytes_per_pixel /= 8;

  	vram_size = h_res * v_res * bytes_per_pixel; //updates the vram's size

  	return 0;
}

int mapping_VRAM()
{

  /* Allow memory mapping */

  mr.mr_base = (phys_bytes) vram_base;	
  mr.mr_limit = mr.mr_base + vram_size;  

  if( OK != (r = sys_privctl(SELF, SYS_PRIV_ADD_MEM, &mr))){
    return 1;
  }

  /* Map memory */

  video_mem = vm_map_phys(SELF, (void *)mr.mr_base, vram_size);

  if(video_mem == MAP_FAILED){

   panic("couldn't map video memory");
   return 1;
  }

  return 0;

}

void* (vg_init)(uint16_t mode)
{

	get_vram_info(mode);

	mapping_VRAM();

	set_graphics_mode(mode);

	return video_mem;
}

int color_pixel(uint16_t x, uint16_t y, uint32_t color)
{
	uint8_t* ptr = video_mem;

  	//puts the pointer on the desired line
  	ptr += (h_res * y * bytes_per_pixel);

  	//puts the pointer on the desired pixel
  	ptr += (x * bytes_per_pixel);

  	//writes the color value in the given pixel
  	for(unsigned j = 0; j < bytes_per_pixel; j++, ptr++)
    	*ptr = (uint8_t)(color >> j * 8);

  	return 0;
}

int (vg_draw_hline)(uint16_t x, uint16_t y, uint16_t len, uint32_t color)
{
	for(unsigned i = 0; i < len; i++){
   
      if((x + i) >= h_res)
        break; // limit of the screen

      if(color_pixel(x + i, y, color) != 0){

        printf("Drawing of the line failed!\n");
        return 1;
     }

  }

    return 0;
}

int (vg_draw_rectangle)(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)
{
	color = get_lsb(color, bits_per_pixel);

  	for(unsigned i = 0; i < height; i++)
  	{

    	if((y + i) >= v_res)
      		break;//limit of the screen

    	if (vg_draw_hline(x, y + i, width, color) != 0)
      		return 1;
  
  	}

  	return 0;
}
